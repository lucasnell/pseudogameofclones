# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Simulate aphid alates seeking host plants.
#'
#'
#' @details # Radius
#' From "The Role of Aphid Behaviour in the Epidemiology of Potato Virus Y:
#' a Simulation Study" by Thomas Nemecek (1993; p. 72), dispersal distances
#' follow a Weibull distribution with shape = 0.6569 and scale = 9.613.
#'
#' The default for the `radius` argument uses the median of this
#' distribution.
#' I'm dividing by 0.75 to convert from meters to plant locations that are
#' 0.75 meters apart (typical spacing for pea):
#' `radius = qweibull(0.5, 0.6569, 9.613) / 0.75`.
#'
#'
#' @param max_t Single integer indicating the number of time steps to simulate.
#' @param plant_xy Two-column integer matrix containing x and y coordinates
#'     for plants. Note that all locations from 1 to the max in each dimension
#'     must be represented by a plant.
#' @param plant_types Integer vector with the same number of items as the
#'     number of rows in `plant_xy` indicating the type of plant each
#'     plant is. Values in this vector must be 1 (virus-infected),
#'     2 (*Pseudomonas*-infected), 3 (none), or 4 (both).
#'     Not all values must be present in the landscape.
#'     Note that all locations from 1 to the max in each dimension
#'     must be represented by a plant.
#' @param alpha Effect of virus infection on alate alighting.
#'     Values `> 1` cause alates to be attracted to virus-infected plants,
#'     while values `< 1` cause them to be repelled by virus-infected plants.
#'     Values must be `> 0`.
#' @param beta Effect of *Pseudomonas* infection on alate alighting.
#'     Values `> 1` cause alates to be attracted to *Pseudomonas*-infected plants,
#'     while values `< 1` cause them to be repelled by *Pseudomonas*-infected plants.
#'     Values must be `> 0`.
#' @param epsilon Effect of virus infection on alate acceptance.
#'     Values `> 1` cause alates to be more likely to stay and feed
#'     (indefinitely) on virus-infected plants,
#'     while values `< 1` cause them to be less likely to stay and feed on
#'     virus-infected plants.
#'     Values must be `> 0`, and `epsilon * w` must be `< 1`.
#' @param w Probability that an alate accepts a plant, meaning that
#'     it stays to feed on it indefinitely.
#'     Must be `> 0` and `< 1`. Defaults to `0.2`.
#' @param radius Max distance that alates will travel between plants.
#'     Defaults to `7.336451`, which is based on previous work.
#'     See "Radius" section below for details.
#' @param xy0 Numeric vector of length 2 indicating starting x and y
#'     coordinates for alate(s). When `xy0 = NULL` and
#'     `randomize_xy0 = FALSE`, alate(s) start at the middle of the
#'     search space (x = 0, y = 0).
#'     This function throws an error when `xy0` is provided and
#'     `randomize_xy0 = TRUE` because these are conflicting.
#'     Defaults to `NULL`.
#' @param randomize_xy0 Single logical for whether to randomize starting
#'     coordinates for alate(s). If `TRUE`, x and y coordinates are
#'     randomly chosen from the landscape.
#'     If `FALSE`, alates start in the middle of the landscape.
#'     Defaults to `TRUE`.
#' @param n_alates Single integer indicating the number of independent
#'     alates to simulate.
#'     Defaults to `1L`.
#' @param summarize Single string for whether and how to summarize output.
#'     Options are `"none"`, `"types"`, or `"xy"`.
#'     See below for details on how this changes the output.
#'     Defaults to `"none"`.
#' @param show_progress Single logical for whether to show progress bar.
#'     Defaults to `FALSE`.
#' @param n_threads Single integer for the number of threads to use.
#'     For now, this is ignored because the multithreading is causing a
#'     strange warning I cannot explain.
#'     Defaults to `1L`.
#'
#' @returns If `summarize = "none"`, a tibble with the columns
#'     `alate` (alate number),
#'     `time` (time), `x` (x coordinate), `y` (y coordinate),
#'    `to` (the plant type the alate traveled to), and
#'     `from` (the plant type the alate traveled from).
#'     If `summarize = "types"`, then it outputs a tibble with the columns
#'     `to`, `from`, and
#'     `n` (the number of times all searchers traveled from this plant type to
#'     this other type).
#'     If `summarize = "xy"`, then it outputs a tibble with the columns
#'     `alate`, `x` (the final x coordinate), and
#'     `y` (the final y coordinate).
#'
#'
#' @export
#'
alate_search_sims <- function(max_t, plant_xy, plant_types, alpha, beta, epsilon = 1, w = 0.2, radius = 7.336451, xy0 = NULL, randomize_xy0 = TRUE, n_alates = 1L, summarize = "none", show_progress = FALSE, n_threads = 1L) {
    .Call(`_pseudogameofclones_alate_search_sims`, max_t, plant_xy, plant_types, alpha, beta, epsilon, w, radius, xy0, randomize_xy0, n_alates, summarize, show_progress, n_threads)
}

#' Simulate targets of different types
#'
#' Simulate locations of targets of different types along an evenly spaced
#' grid of integers, where the placement of one target can affect subsequent
#' placement of other targets.
#' Target locations are drawn from all combinations of `1` to
#' `x_size-1` and `1` to `y_size-1`.
#' I'm subtracting 1 because the landscape in `searcher_sims` is defined by
#' the bounds `c(0, x_size)` and `c(0, y_size)`, so this subtraction
#' keeps a gap of 1 between the most extreme locations and the bounds
#' of the landscape.
#' This prevents targets from being located on the bounds.
#'
#'
#' @param x_size Single integer indicating x dimension of search area.
#'     Locations will be drawn from `1` to `x_size-1`.
#'     See description above for why.
#' @param y_size Single integer indicating y dimension of search area.
#'     Locations will be drawn from `1` to `y_size-1`.
#'     See description above for why.
#' @param wt_mat Square numeric matrix indicating how sample weighting on
#'     neighboring locations is affected by a target of each type being
#'     placed in a particular spot.
#'     Item `wt_mat[i,j]` indicates the effect of target type `i` on
#'     subsequent samplings of target type `j`.
#'     Values above 1 cause neighboring locations to be more likely to be
#'     sampled later, while values below 1 cause them to be less likely
#'     sampled.
#'     For locations that have been adjusted using `wt_mat` multiple times,
#'     the weights are multiplied by each other
#'     (e.g., `w *= wt_mat[1,3]` at time `t`, then
#'     `w *= wt_mat[1,2]` at time `t+1`).
#'     All weights start with values of `1`.
#'     The matrix should have the same number of rows and columns as the
#'     number of target types.
#' @param n_samples Integer vector indicating the number of samples to
#'     produce per target type. The length should equal the number of
#'     target types, and all values should be `>=1`.
#' @param allow_overlap Single logical indicating whether to allow
#'     targets to be more than one type.
#'     An example of a target being multiple types would be a plant that
#'     hosts an epiphytic bacteria and is also infected with a virus.
#'     Defaults to `TRUE`.
#' @param fill_all Single logical indicating whether to have a target at all
#'     points in the landscape. If `TRUE`, then locations where no targets
#'     were simulated will be assigned to a target type `length(n_samples)+1`.
#'     Defaults to `TRUE`.
#'
#'
#' @return A [`tibble`][tibble::tbl_df] with columns `x`, `y`, and `type`.
#'
#'
#' @export
#'
target_type_sims <- function(x_size, y_size, wt_mat, n_samples, allow_overlap = TRUE, fill_all = TRUE) {
    .Call(`_pseudogameofclones_target_type_sims`, x_size, y_size, wt_mat, n_samples, allow_overlap, fill_all)
}

#' Simulate searchers seeking targets.
#'
#' @param d Single numeric indicating search rate of searcher.
#' @param max_t Single integer indicating the number of time steps to simulate.
#' @param x_size Single numeric indicating x dimension of search area.
#'     Bounds will be `c(0, x_size)`.
#' @param y_size Single numeric indicating y dimension of search area.
#'     Bounds will be `c(0, y_size)`.
#' @param target_xy Two-column numeric matrix containing x and y coordinates
#'     for targets.
#' @param target_types Integer vector with the same number of items as the
#'     number of rows in `target_xy` indicating the type of target each
#'     target is. Targets can vary in their `l_star`, `l_int`, `bias`,
#'     `n_stay`, and `n_ignore` parameters (see descriptions below).
#'     This vector should consist of integers from 1 to the number of items
#'     in the arguments `l_star`, `l_int`, `bias`, `n_stay`, and `n_ignore`.
#'     It's allowed that some target types don't show up in this vector
#'     since this can be useful for simulations where you remove or replace
#'     target type(s).
#' @param l_star List where each element is a numeric vector indicating,
#'     for each target type, the distance(s) from searcher to target that
#'     causes targets to bias searcher movement.
#'     Its length should be equal to the number of unique type(s) of targets.
#'     Target types can have multiple `l_star` values if they have, for
#'     example, both a virus that attracts searchers and an epiphytic
#'     bacteria that repels them. If the cues from the virus and bacteria
#'     happen at different spatial scales, then this would result in
#'     multiple `l_star` values. It would also result in multiple `bias`
#'     values for targets of this type.
#'     For multiple values of `l_star` and `bias`, it's assumed that they
#'     are ordered the same (i.e., `l_star[[i]][[j]]` coincides with
#'     `bias[[i]][[j]]`).
#'     It's also required that within the same target type, higher values
#'     of `l_star` coincide with lower values of `abs(bias)`.
#' @param l_int Numeric vector indicating, for each target type,
#'     the distance from searcher to target that causes an interaction.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param bias List where each item is a numeric vector indicating, for
#'     each target type, the bias(es) the target causes searcher movement
#'     once they're `<= l_star` away from it. Values range from -1 to 1,
#'     with negative values resulting in searchers being repelled.
#'     Values of +1 (-1) cause searchers to move directly towards (away from)
#'     targets once within `l_star`.
#'     Values nearer to zero cause movement that is more similar to
#'     a random walk.
#'     Its length should be equal to the number of unique type(s) of targets.
#'     See the description for parameter `l_star` for an example of why you
#'     might need multiple `bias` values for one target type.
#' @param n_stay Numeric vector indicating, for each target type,
#'     the number of time steps searchers stay at targets when they interact
#'     with them.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param n_ignore Numeric vector indicating, for each target type,
#'     the number of time steps searchers ignore targets after
#'     interacting with them.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param xy0 Numeric vector of length 2 indicating starting x and y
#'     coordinates for searcher(s). When `xy0 = NULL` and
#'     `randomize_xy0 = FALSE`, searcher(s) start at the middle of the
#'     search space (x = 0, y = 0).
#'     This function throws an error when `xy0` is provided and
#'     `randomize_xy0 = TRUE` because these are conflicting.
#'     Defaults to `NULL`.
#' @param randomize_xy0 Single logical for whether to randomize starting
#'     coordinates for searcher(s). If `TRUE`, x and y coordinates are
#'     generated from a random uniform distribution ranging from the lower
#'     to upper bound for each dimension.
#'     Defaults to `TRUE`.
#' @param n_searchers Single integer indicating the number of independent
#'     searchers to simulate.
#'     Defaults to `1L`.
#' @param summarize Single logical for whether to summarize output by
#'     searcher. See below for details on how this changes the output.
#'     Defaults to `FALSE`.
#' @param show_progress Single logical for whether to show progress bar.
#'     Defaults to `FALSE`.
#' @param n_threads Single integer for the number of threads to use.
#'     For now, this is ignored because the multithreading is causing a
#'     strange warning I cannot explain.
#'     Defaults to `1L`.
#'
#' @returns If `summarize = FALSE`, then it outputs a tibble with the columns
#'     `searcher` (searcher number),
#'     `time` (time), `x` (x coordinate), `y` (y coordinate),
#'     `tar` (which target is searcher interacting with (within `l_int`)?),
#'     `type` (which target type is searcher interacting with?),
#'      and
#'     `hit` (logical - is searcher interacting with a new target?).
#'     Columns `tar` and `type` are `0` if the searcher is not on any targets.
#'     If `summarize = TRUE`, then it outputs a tibble with the columns
#'     `searcher` (searcher number),
#'     `type` (which target type is searcher interacting with?),
#'     `on` (integer - how many time steps did the searcher spend on this
#'     type of target?).
#'     and
#'     `hit` (integer - how many times did this searcher interact with
#'     a new target of this type?).
#'
#'
#' @export
#'
searcher_sims <- function(d, max_t, x_size, y_size, target_xy, target_types, l_star, bias, l_int, n_stay, n_ignore, xy0 = NULL, randomize_xy0 = TRUE, n_searchers = 1L, summarize = FALSE, show_progress = FALSE, n_threads = 1L) {
    .Call(`_pseudogameofclones_searcher_sims`, d, max_t, x_size, y_size, target_xy, target_types, l_star, bias, l_int, n_stay, n_ignore, xy0, randomize_xy0, n_searchers, summarize, show_progress, n_threads)
}

make_aphids_ptr <- function(aphid_list) {
    .Call(`_pseudogameofclones_make_aphids_ptr`, aphid_list)
}

#' Logit and inverse logit functions.
#'
#'
#' @export
#'
logit <- function(p) {
    .Call(`_pseudogameofclones_logit`, p)
}

#' @describeIn logit
#'
#' @export
#'
inv_logit <- function(a) {
    .Call(`_pseudogameofclones_inv_logit`, a)
}

#' Create Leslie matrix from aphid info
#'
#' @param instar_days Integer vector of the number of stages (days) per aphid instar.
#' @param surv_juv Single numeric of daily juvenile survival.
#' @param surv_adult Numeric vector of aphid adult survivals by stage.
#' @param repro Numeric vector of aphid reproductive rates by stage.
#'
#'
#' @noRd
leslie_matrix <- function(instar_days, surv_juv, surv_adult, repro) {
    .Call(`_pseudogameofclones_leslie_matrix`, instar_days, surv_juv, surv_adult, repro)
}

#' Compute the "stable age distribution" from a Leslie matrix
#'
#' @param leslie Leslie matrix of the population.
#'
#' @noRd
#'
#' @return Vector with the stable age distribution given the Leslie matrix.
#'
sad_leslie <- function(leslie) {
    .Call(`_pseudogameofclones_sad_leslie`, leslie)
}

fields_to_data_frames <- function(all_fields_ptr) {
    .Call(`_pseudogameofclones_fields_to_data_frames`, all_fields_ptr)
}

fields_from_vectors <- function(all_fields_ptr, N_vecs) {
    invisible(.Call(`_pseudogameofclones_fields_from_vectors`, all_fields_ptr, N_vecs))
}

make_field_ptr <- function(aphid_demog_error, aphid_density_0, wasp_demog_error, wasp_density_0, wasp_delay, mummy_density_0, environ_error, aphids_ptr, wasp_ptr, n_fields, K, K_y, pred_rate, extinct_N, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, new_rel_attack) {
    .Call(`_pseudogameofclones_make_field_ptr`, aphid_demog_error, aphid_density_0, wasp_demog_error, wasp_density_0, wasp_delay, mummy_density_0, environ_error, aphids_ptr, wasp_ptr, n_fields, K, K_y, pred_rate, extinct_N, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, new_rel_attack)
}

make_all_fields_vec_ptr <- function(one_field_ptr, n_reps) {
    .Call(`_pseudogameofclones_make_all_fields_vec_ptr`, one_field_ptr, n_reps)
}

get_field_pars <- function(all_fields_in_ptr) {
    .Call(`_pseudogameofclones_get_field_pars`, all_fields_in_ptr)
}

restarted_field_ptr <- function(all_fields_in_ptr, aphid_demog_error, wasp_demog_error, K, K_y, pred_rate, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract) {
    .Call(`_pseudogameofclones_restarted_field_ptr`, all_fields_in_ptr, aphid_demog_error, wasp_demog_error, K, K_y, pred_rate, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract)
}

make_perturb_ptr <- function(perturb_when, perturb_where, perturb_who, perturb_how) {
    .Call(`_pseudogameofclones_make_perturb_ptr`, perturb_when, perturb_where, perturb_who, perturb_how)
}

sim_fields_cpp <- function(all_fields_vec_ptr, perturb_ptr, max_t, save_every, sep_adults, n_threads, show_progress, stage_ts_out) {
    .Call(`_pseudogameofclones_sim_fields_cpp`, all_fields_vec_ptr, perturb_ptr, max_t, save_every, sep_adults, n_threads, show_progress, stage_ts_out)
}

restart_fill_other_pars <- function(all_fields_in_ptr, K, alate_b0, alate_b1, alate_field_disp_p, K_y, s_y, a, k, h, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, mum_smooth, pred_rate) {
    .Call(`_pseudogameofclones_restart_fill_other_pars`, all_fields_in_ptr, K, alate_b0, alate_b1, alate_field_disp_p, K_y, s_y, a, k, h, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, mum_smooth, pred_rate)
}

make_wasps_ptr <- function(rel_attack, a, k, h, sex_ratio, s_y, sigma_y, mummy_smooth, mummy_dev_time) {
    .Call(`_pseudogameofclones_make_wasps_ptr`, rel_attack, a, k, h, sex_ratio, s_y, sigma_y, mummy_smooth, mummy_dev_time)
}

