# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Simulate searchers seeking targets.
#'
#' @param d Single numeric indicating search rate of searcher.
#' @param max_t Single integer indicating the number of time steps to simulate.
#' @param x_size Single numeric indicating x dimension of search area.
#'     Bounds will be `c(0, x_size)`.
#' @param y_size Single numeric indicating y dimension of search area.
#'     Bounds will be `c(0, y_size)`.
#' @param target_xy Two-column numeric matrix containing x and y coordinates
#'     for targets.
#' @param target_types Integer vector with the same number of items as the
#'     number of rows in `target_xy` indicating the type of target each
#'     target is. Targets can vary in their `l_star`, `l_int`, `bias`,
#'     `n_stay`, and `n_ignore` parameters (see descriptions below).
#'     This vector should consist of integers from 1 to the number of items
#'     in the arguments `l_star`, `l_int`, `bias`, `n_stay`, and `n_ignore`.
#' @param l_star Numeric vector indicating, for each target type,
#'     the distance from searcher to target that causes targets to bias
#'     searcher movement.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param l_int Numeric vector indicating, for each target type,
#'     the distance from searcher to target that causes an interaction.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param bias Numeric vector indicating, for each target type,
#'     the bias the target causes searcher movement once they're `<= l_star`
#'     away from it. Values range from -1 to 1,
#'     with negative values resulting in searchers being repelled.
#'     Values of +1 (-1) cause searchers to move directly towards (away from)
#'     targets once within `l_star`.
#'     Values nearer to zero cause movement that is more similar to
#'     a random walk.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param n_stay Numeric vector indicating, for each target type,
#'     the number of time steps searchers stay at targets when they interact
#'     with them.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param n_ignore Numeric vector indicating, for each target type,
#'     the number of time steps searchers ignore targets after
#'     interacting with them.
#'     Its length should be equal to the number of unique type(s) of targets.
#' @param xy0 Numeric vector of length 2 indicating starting x and y
#'     coordinates for searcher(s). When `xy0 = NULL` and
#'     `randomize_xy0 = FALSE`, searcher(s) start at the middle of the
#'     search space (x = 0, y = 0).
#'     This function throws an error when `xy0` is provided and
#'     `randomize_xy0 = TRUE` because these are conflicting.
#'     Defaults to `NULL`.
#' @param randomize_xy0 Single logical for whether to randomize starting
#'     coordinates for searcher(s). If `TRUE`, x and y coordinates are
#'     generated from a random uniform distribution ranging from the lower
#'     to upper bound for each dimension.
#'     Defaults to `TRUE`.
#' @param n_reps Single integer indicating the number of independent
#'     repetitions to run. This can be thought of as the number of searchers
#'     on the landscape if searchers are independent of one another.
#'     Defaults to `1L`.
#' @param show_progress Single logical for whether to show progress bar.
#'     Defaults to `FALSE`.
#' @param n_threads Single integer for the number of threads to use.
#'     For now, this is ignored because the multithreading is causing a
#'     strange warning I cannot explain.
#'     Defaults to `1L`.
#'
#' @returns A tibble with the columns `rep` (repetition number),
#'     `time` (time), `x` (x coordinate), `y` (y coordinate),
#'     `tar` (which target is searcher interacting with (within `l_int`)?),
#'     `type` (which target type is searcher interacting with?),
#'      and
#'     `hit` (logical - is searcher interacting with a new target?).
#'     Columns `tar` and `type` are `0` if the searcher is not on any targets.
#'
#'
#' @export
#'
searcher_sims <- function(d, max_t, x_size, y_size, target_xy, target_types, l_star, l_int, bias, n_stay, n_ignore, xy0 = NULL, randomize_xy0 = TRUE, n_reps = 1L, show_progress = FALSE, n_threads = 1L) {
    .Call(`_pseudogameofclones_searcher_sims`, d, max_t, x_size, y_size, target_xy, target_types, l_star, l_int, bias, n_stay, n_ignore, xy0, randomize_xy0, n_reps, show_progress, n_threads)
}

make_aphids_ptr <- function(aphid_list) {
    .Call(`_pseudogameofclones_make_aphids_ptr`, aphid_list)
}

#' Logit and inverse logit functions.
#'
#'
#' @export
#'
logit <- function(p) {
    .Call(`_pseudogameofclones_logit`, p)
}

#' @describeIn logit
#'
#' @export
#'
inv_logit <- function(a) {
    .Call(`_pseudogameofclones_inv_logit`, a)
}

#' Create Leslie matrix from aphid info
#'
#' @param instar_days Integer vector of the number of stages (days) per aphid instar.
#' @param surv_juv Single numeric of daily juvenile survival.
#' @param surv_adult Numeric vector of aphid adult survivals by stage.
#' @param repro Numeric vector of aphid reproductive rates by stage.
#'
#'
#' @noRd
leslie_matrix <- function(instar_days, surv_juv, surv_adult, repro) {
    .Call(`_pseudogameofclones_leslie_matrix`, instar_days, surv_juv, surv_adult, repro)
}

#' Compute the "stable age distribution" from a Leslie matrix
#'
#' @param leslie Leslie matrix of the population.
#'
#' @noRd
#'
#' @return Vector with the stable age distribution given the Leslie matrix.
#'
sad_leslie <- function(leslie) {
    .Call(`_pseudogameofclones_sad_leslie`, leslie)
}

fields_to_data_frames <- function(all_fields_ptr) {
    .Call(`_pseudogameofclones_fields_to_data_frames`, all_fields_ptr)
}

fields_from_vectors <- function(all_fields_ptr, N_vecs) {
    invisible(.Call(`_pseudogameofclones_fields_from_vectors`, all_fields_ptr, N_vecs))
}

make_field_ptr <- function(aphid_demog_error, aphid_density_0, wasp_demog_error, wasp_density_0, wasp_delay, mummy_density_0, environ_error, aphids_ptr, wasp_ptr, n_fields, K, K_y, pred_rate, extinct_N, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, new_rel_attack) {
    .Call(`_pseudogameofclones_make_field_ptr`, aphid_demog_error, aphid_density_0, wasp_demog_error, wasp_density_0, wasp_delay, mummy_density_0, environ_error, aphids_ptr, wasp_ptr, n_fields, K, K_y, pred_rate, extinct_N, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, new_rel_attack)
}

make_all_fields_vec_ptr <- function(one_field_ptr, n_reps) {
    .Call(`_pseudogameofclones_make_all_fields_vec_ptr`, one_field_ptr, n_reps)
}

get_field_pars <- function(all_fields_in_ptr) {
    .Call(`_pseudogameofclones_get_field_pars`, all_fields_in_ptr)
}

restarted_field_ptr <- function(all_fields_in_ptr, aphid_demog_error, wasp_demog_error, K, K_y, pred_rate, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract) {
    .Call(`_pseudogameofclones_restarted_field_ptr`, all_fields_in_ptr, aphid_demog_error, wasp_demog_error, K, K_y, pred_rate, constant_wasps, alate_field_disp_p, wasp_disp_m0, wasp_disp_m1, wasp_field_attract)
}

make_perturb_ptr <- function(perturb_when, perturb_where, perturb_who, perturb_how) {
    .Call(`_pseudogameofclones_make_perturb_ptr`, perturb_when, perturb_where, perturb_who, perturb_how)
}

sim_fields_cpp <- function(all_fields_vec_ptr, perturb_ptr, max_t, save_every, sep_adults, n_threads, show_progress, stage_ts_out) {
    .Call(`_pseudogameofclones_sim_fields_cpp`, all_fields_vec_ptr, perturb_ptr, max_t, save_every, sep_adults, n_threads, show_progress, stage_ts_out)
}

restart_fill_other_pars <- function(all_fields_in_ptr, K, alate_b0, alate_b1, alate_field_disp_p, K_y, s_y, a, k, h, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, mum_smooth, pred_rate) {
    .Call(`_pseudogameofclones_restart_fill_other_pars`, all_fields_in_ptr, K, alate_b0, alate_b1, alate_field_disp_p, K_y, s_y, a, k, h, wasp_disp_m0, wasp_disp_m1, wasp_field_attract, mum_smooth, pred_rate)
}

make_wasps_ptr <- function(rel_attack, a, k, h, sex_ratio, s_y, sigma_y, mummy_smooth, mummy_dev_time) {
    .Call(`_pseudogameofclones_make_wasps_ptr`, rel_attack, a, k, h, sex_ratio, s_y, sigma_y, mummy_smooth, mummy_dev_time)
}

