---
title: "Choose priors"
author: "Lucas A. Nell"
date: "2018-07-04"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Choose priors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dev = "svglite", 
  fig.width = 6,
  fig.height = 4,
  echo = FALSE
)
knitr::opts_knit$set(root.dir = normalizePath(".."))
options(tibble.print_min = 4L, tibble.print_max = 4L)
```
```{r source_Rprofile, eval = FALSE}
source(".Rprofile")
```



```{r library_pkgs, warning=FALSE}
suppressPackageStartupMessages({
    library(clonewars)
})
bayesplot::color_scheme_set("viridis")
dlnorm_ <- function(x, location, scale) {
    dlnorm(x, meanlog = location, sdlog = scale)
}
```


This document outlines the structure of the model and what priors are required.
In general, my goal is to create weakly informative prior distributions:

> We characterize a prior distribution as *weakly informative* if it is proper but
> is set up so that the information it does provide is intentionally weaker
> than whatever actual prior knowledge is available. (p 55, Gelman et al. 2014)

Gelman, A., J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, and D. B. Rubin. 2014.
*Bayesian Data Analysis*. Third edition. CRC Press, Boca Raton, FL, USA.



# Model description

Below is the model I'm fitting:

$$
X_{t+1} = X_t + r \left( 1 - \alpha ~ \text{e}^{X_t} \right) + \varepsilon
$$

where $X_t$ is log aphid counts for a particular plant at time $t$,
$r$ is the aphid line's growth rate,
$\alpha$ is the line's density dependence,
and
$\varepsilon$ is process error.


### Note on $Z$ and non-centered distributions

Below, all mentions of $Z$ refer to Z-scores (i.e., $Z \sim \text{N}(0,1)$).
These are used to generate non-centered parameterizations of all distributions
(see section 28.6 in the Stan Modeling Language User's Guide and Reference Manual,
version 2.17.0).
Each $Z$ in an equation is not referring to the same object, but to a separate
Z-score used to generate deviates from the focal distribution.



### Estimating process error


\begin{align}
    \varepsilon &= s_\varepsilon Z \\
    s_\varepsilon &\sim \exp ( \tau + \sigma_\tau Z ) \\
\end{align}



#### Estimated from model:

- $s_\varepsilon$: standard deviation of the process error


#### Priors to define:

- $\tau$: mean for the normal distribution that generates $\log(s_\varepsilon)$ values
- $\sigma_\tau$: sd for the normal distribution that generates $\log(s_\varepsilon)$
  values




### Estimating growth rates 

Growth rates are bound $\ge 0$ and have one estimate per aphid line,
resulting in a vector of growth rates, $\mathbf{R}$.
The growth rate estimate for clonal line $i$ is generated as follows:


\begin{align}
    
    \mathbf{R}_i &= \exp \left( \theta + s_\theta ~ Z \right) \\
    
    \theta &= \mu_{\theta} + \sigma_{\theta} ~ Z \\
    s_\theta &= \exp(\gamma + \sigma_\gamma ~ Z) \\
    
\end{align}



#### Estimated from model:

- $\mathbf{R}$: vector of growth rates for each aphid line
- $\theta$: among-line mean of the log-transformed growth rates
- $s_\theta$: among-line standard deviation of the log-transformed growth rates


#### Priors to define:

- $\mu_\theta$: mean of the normal distribution that generates $\theta$ values
- $\sigma_\theta$: standard deviation of the normal distribution that generates
  $\theta$ values
- $\gamma$: mean for the normal distribution that generates $\log(s_\theta)$ values
- $\sigma_\gamma$: sd for the normal distribution that generates $\log(s_\theta)$ values





### Estimating density dependence

Density dependences are bound between 0 and 1 and also have estimates for each line.
They differ from $r$ in that they also have variance within aphid lines, to account
for effects of variability in plant resources affecting aphid density dependence.
I used the inverse logit function to bound final $\alpha$ estimates between 0 and 1.
For clonal line $i$ and plant $j$, estimates are generated as follows:


\begin{align}

    \mathbf{A}_i &= \text{logit}^{-1} \hspace{-0.25em}
        \left(
            \phi + s_\phi ~ Z
        \right) \\
    
    \mathbf{P}_{j} &= \text{logit}^{-1} \hspace{-0.25em}
        \left(
            \phi + s_\phi ~ Z + 
            \mathbf{S}_{\mathbf{L}_j} ~ Z
        \right) \\
    
    \phi &= \mu_{\phi} + \sigma_{\phi} ~ Z \\
    s_{\phi} &= \exp(\delta + \sigma_\delta ~ Z) \\
    \mathbf{S} &= \exp(\zeta + \sigma_\zeta ~ Z) \\
\end{align}




#### Estimated from model:

- $\mathbf{A}$: vector of density dependences for each aphid line
- $\mathbf{P}$: vector of density dependences for each plant (i.e., each time series)
- $\phi$: among-line mean of the logit-transformed density dependences
- $s_\phi$: among-line standard deviation of the logit-transformed density dependences
- $\mathbf{S}$: vector of the within-line standard deviations in the
    logit-transformed density dependences for each aphid line


#### Priors to define:

- $\mu_\phi$: mean of the normal distribution that generates $\phi$ values
- $\sigma_\phi$: standard deviation of the normal distribution that generates $\phi$
  values
- $\delta$: mean for the normal distribution that generates $\log(s_\phi)$ values
- $\sigma_\delta$: sd for the normal distribution that generates $\log(s_\phi)$ values
- $\zeta$: mean for the normal distribution that generates values in $\log(\mathbf{S})$
- $\sigma_\zeta$: sd for the normal distribution that generates values in
  $\log(\mathbf{S})$


#### Other:

- $\mathbf{L}_j$ is an identifier vector that returns the index to the aphid line
  for time series $j$.









# Creating priors




## Process error priors

```{r define_process_priors}
# Below are meanlog and sdlog parameters for the log-normal distribution
# that generates values for the process error standard deviation
tau <- signif(log(0.15), 4)
sigma_tau <- 1
```


$s_\varepsilon$ is bound $\ge 0$ and sampled as $\sim \text{Lognormal}(\tau, \sigma_\tau)$
Based on simulations, an $s_\varepsilon$ of 1 would be very high---so high as to be not
realistically possible.
Values of ~ 0.15 seemed to result in simulations matching some preliminary experimental
results we've seen in the lab.
Below, `r sprintf('"sigma%.2f"', tau)` is simulated data with process error set to
`r tau`, "sigma1" has process error set to 1.0.
The others are the preliminary data.

```{r load_prior}
load_prior_data() %>% 
    add_row(line = paste0("sigma", signif(exp(tau), 2)), rep = rep(1:5, each=16),
            date = rep(5:20,5),
            X = sim_lines(R0 = 0.2, alpha = 1/1000, n_reps = 5, nobs_ts = rep(16, 5), 
                          sigma_process = exp(tau)) %>% 
                as.numeric()) %>% 
    add_row(line = "sigma1", rep = rep(1:5, each=16), date = rep(5:20,5),
            X = sim_lines(R0 = 0.2, alpha = 1/1000, n_reps = 5, nobs_ts = rep(16, 5), 
                          sigma_process = 1) %>% 
                as.numeric()) %>% 
    mutate(rep = factor(rep)) %>% 
    ggplot(aes(date, X)) +
    geom_line(aes(color = rep)) +
    facet_wrap(~ line) +
    scale_color_brewer(palette = "Dark2", guide = FALSE)
```


To sample $s_\varepsilon$,
I chose a log-normal distribution with `log(0.15)` (`r tau`) as the
$tau$ and `r sigma_tau` for $\sigma_\tau$ because this results in low densities at values
close to 1.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.

```{r process_error_plot}
compare_priors("normal", tau, sigma_tau, xlim = tau + c(-1,1) * 3.25) +
    geom_vline(xintercept = tau) +
    ggtitle(expression(s[epsilon] %~% plain("Lognormal")(tau * "," ~ sigma[tau]))) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_tau)) +
    scale_x_continuous(breaks = log(c(1 * 10^(-2:0), 0.05, 0.5)),
                       labels = c(1 * 10^(-2:0), 0.05, 0.5)) +
    NULL
```






## Growth rate priors


From data sent to me from A.R. Ives related to this paper:

Meisner, M. H., J. P. Harmon, and A. R. Ives. 2014. Temperature effects on
long-term population dynamics in a parasitoid–host system.
*Ecological Monographs* __84__:457–476.

For fecundity, juvenile survival, and adult survival, the dataset had low and high
estimates.
I created two Leslie matrices, one with all of the high estimates and another
with all the lower estimates.
For each of these Leslie matrices, I estimated the intrinsic daily rate of increase
($r$) in aphid populations in the lab as $r = \log(\lambda)$, where $\lambda$ is the
dominant eigenvector of the matrix.
Thus I have fast and slow estimates of population growth to use as prior information
about our population-growth assays.


```{r load_leslies}
fast <- read_csv("data-raw/leslie_fast.csv", col_names = FALSE,
                 col_types = cols(.default = col_double())) %>% 
    as.matrix() %>% 
    eigen() %>% 
    .[["values"]] %>% 
    .[1] %>% 
    Re() %>% 
    log()
slow <- read_csv("data-raw/leslie_slow.csv", col_names = FALSE,
                 col_types = cols(.default = col_double())) %>% 
    as.matrix() %>% 
    eigen() %>% 
    .[["values"]] %>% 
    .[1] %>% 
    Re() %>% 
    log()
cat(sprintf("fast = %.4g\n", fast))
cat(sprintf("slow = %.4g\n", slow))
```



\begin{align}
    
    \mathbf{R}_i &= \exp \left( \theta + s_\theta ~ Z \right) \\
    
    \theta &= \mu_{\theta} + \sigma_{\theta} ~ Z \\
    s_\theta &= \exp(\gamma + \sigma_\gamma ~ Z) \\
    
\end{align}


```{r define_R_priors}
# mean and SD  of the normal distribution that generates theta values
#   (theta = among-line mean of the log-transformed growth rates)
mu_theta <- c(fast, slow) %>% 
    log() %>% 
    mean() %>% 
    signif(4)
sigma_theta <- c(fast, slow) %>%
    log() %>% 
    sd() %>% 
    `*`(., 10) %>% 
    signif(4)

# meanlog and sdlog parameters for the log-normal distribution that generates
#   s_theta values
#   (s_theta = among-line standard deviation of the log-transformed growth rates)
gamma <- c(fast, slow) %>% 
    log() %>% 
    sd() %>% 
    log() %>% 
    signif(4)
sigma_gamma <- 1.0
```


I also simulated some data with $r = \{ 0.25, 0.5, 0.75, 1.25 \}$ to compare the 
simulations to the preliminary data.
Below, "rX" indicates a panel of simulated data with $r$ set to the number X.
The others are the preliminary data.
From these simulations, values of $r > 0.5$ seem pretty unlikely.


```{r load_prior2, fig.height=6}
sim_R <- function(df_, R_, alpha_ = 1/2000) {
    add_row(df_, 
            line = paste0("r", R_), rep = rep(1:5, each=15), 
            date = rep(1:15, 5) + 3,
            X = sim_lines(R0 = R_, alpha = alpha_, n_reps = 5,
                          nobs_ts = rep(15, 5), sigma_process = exp(tau)) %>% 
                as.numeric())
}

load_prior_data() %>% 
    sim_R(0.25) %>% 
    sim_R(0.5) %>% 
    sim_R(0.75) %>% 
    sim_R(1) %>% 
    sim_R(1.25) %>% 
    mutate(rep = factor(rep)) %>% 
    ggplot(aes(date, X)) +
    geom_line(aes(color = rep)) +
    facet_wrap(~ line, nrow = 3) +
    scale_color_brewer(palette = "Dark2", guide = FALSE)
```



For the among-line mean of the log-transformed growth rates ($\mu_\theta$), 
I used `mean(log(c(fast, slow)))`, `r mu_theta`.
For the standard deviation of $\mu_\theta$ ($\sigma_\theta$),
I used `sd(log(c(fast, slow))) * 10`, `r sigma_theta`.
I multiplied by 10 to add extra uncertainty because of the limited number of lines
from which I derived my priors.
In the plot below, I've exponentiated the x-axis so that it displays the values of
$r$ that would result.


```{r mean_theta_distr}
compare_priors(dlnorm_, mu_theta, sigma_theta, xlim = c(0, 1.25)) +
    geom_vline(xintercept = exp(mu_theta)) +
    ggtitle(expression(italic(r) == plain(exp)(theta %~% plain(N)(
        mu[theta] * "," ~ sigma[theta]^2)))) +
    NULL
```


For sampling $s_\theta$, I use `sd(log(c(fast, slow)))` (`r gamma`) for the location
parameter and `r sigma_gamma` for the scale parameter.
The latter was chosen to indicate even more uncertainty in $s_\theta$ than in
$\mu_\theta$.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.

```{r s_theta_distr}
compare_priors("normal", gamma, sigma_gamma, xlim = gamma + c(-1,1) * 3.25) +
    geom_vline(xintercept = gamma) +
    ggtitle(expression(s[theta] %~% plain("Lognormal")(gamma * "," ~ sigma[gamma]))) +
    scale_x_continuous(breaks = log(c(2 * 10^(-2:0), 0.01, 0.1, 1)),
                       labels = c(2 * 10^(-2:0), 0.01, 0.1, 1)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_gamma)) +
    NULL
```





## Density dependence


For density dependence, I'm going to use data from preliminary population-growth
assays that used the same methods that we're using.
We conducted these assays on 4 aphid lines that we no longer maintain in the lab
and won't be using for our analyses or cage experiments.

If we look at the deterministic portion of our model...

$$
X_{t+1} = X_t + r \left( 1 - \alpha ~ \text{e}^{X_t} \right)
$$
... $X_{t+1} = X_t$ when $\alpha = 1 / \exp(X_t) = 1 / N_t$.
Because each repetition is run until the plant dies and populations crash,
I'll assume that for each repetition, our estimate of $\alpha$ is $1 / \max(N_t)$.

Here is how I coded it:

```{r load_prior_data_alpha, echo = TRUE}
prior_df <- load_prior_data() %>% 
    group_by(line, rep) %>% 
    summarize(alpha = 1 / max(N)) %>% 
    ungroup()
prior_df
```
```{r logit_funs_and_application}
logit <- function(p) log(p / (1-p))
inv_logit <- function(x) 1 / (1 + exp(-x))
prior_df <- prior_df %>% 
    mutate(logit_alpha = logit(alpha))
```



```{r define_alpha_priors}
# mean and standard deviations of the normal distribution that generates phi values
#   (phi = among-line mean of the logit-transformed density dependences)
mu_phi <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    signif(4)
sigma_phi <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = sd(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    `*`(., 10) %>%
    signif(4)

# - $\delta$: meanlog parameter for the log-normal distribution that generates
#   $s_\phi$ values
# - $\sigma_\delta$: sdlog parameter for the log-normal distribution that generates
#   $s_\phi$ values
# - $\zeta$: meanlog parameter for the log-normal distribution that generates
#   values in $\mathbf{S}$
# - $\sigma_\zeta$: sdlog parameter for the log-normal distribution that generates
#   values in $\mathbf{S}$

# meanlog and sdlog parameters for the log-normal distribution that generates
#   s_phi values
#   (s_phi = among-line standard deviation of the logit-transformed density dependences)
delta <- prior_df %>% 
    group_by(line) %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>% 
    ungroup() %>% 
    summarize(logit_alpha = sd(logit_alpha)) %>% 
    .[["logit_alpha"]] %>% 
    log() %>% 
    signif(4)
sigma_delta <- 2

# meanlog and sdlog parameters for the log-normal distribution that generates
#   values in S
#   (S = vector of the within-line standard deviations in the logit-transformed
#    density dependences for each aphid line)
zeta <- prior_df %>%
    group_by(line) %>% 
    summarize(logit_alpha = logit_alpha %>% sd() %>% log()) %>% 
    ungroup() %>% 
    summarize(logit_alpha = mean(logit_alpha)) %>%
    .[["logit_alpha"]] %>%
    signif(4)
sigma_zeta <- prior_df %>%
    group_by(line) %>%
    summarize(logit_alpha = logit_alpha %>% sd() %>% log()) %>%
    ungroup() %>%
    summarize(logit_alpha = sd(logit_alpha)) %>%
    .[["logit_alpha"]] %>%
    `*`(., 2) %>%
    signif(4)
```


### Among-line distribution

For estimates relating to the among-line distribution of $\text{logit}(\alpha)$,
I first calculated $\text{logit}(\alpha)$ for each line-rep combo,
then calculated the mean for each line.
After that, I used the mean across lines, `r sprintf("%.3f", mu_phi)`,
as my prior for $\mu_\phi$.
I multiplied the standard deviation across lines by 10 (resulting in `r sigma_phi`)
for my prior on $\sigma_\phi$ to decrease my certainty in estimates.
For the plot below, I inverse-logit transformed the x-axis to show the resulting $\alpha$
values from these priors.
It still has pretty low densities above 0.5, which is reasonable because that
would indicate a "carrying capacity" of < 2.

```{r alpha_overall_mean_plot}
logit_dlnorm <- function(p, location, scale) {
    dnorm(logit(p), location, scale)
}
compare_priors(logit_dlnorm, mu_phi, sigma_phi, xlim = c(0, 1)) +
    geom_vline(xintercept = inv_logit(mu_phi), linetype = 2) +
    ggtitle(expression(alpha == {plain("logit")^{-1}}(
        phi %~% plain(N)(mu[phi] * "," ~ sigma[phi]^2))))
```


For the distribution of $s_\phi$ values, I used the log-transformed SD for among-line 
mean $\text{logit}(\alpha)$ (`r delta`) for the meanlog parameter ($\delta$), and
`r sigma_delta` for the sdlog parameter ($\sigma_\delta$).
The latter was chosen simply because I'm not very sure of what it should be, and 
this value results in a pretty flat prior distribution.
Note that below, the x-axis is log-transformed, but axis labels indicate 
non-transformed values.


```{r alpha_line_means_plot}
compare_priors("normal", delta, sigma_delta, xlim = delta + c(-1,1) * sigma_delta * 3) +
    geom_vline(xintercept = delta) +
    ggtitle(expression(s[phi] %~% plain("Lognormal")(delta * "," ~ sigma[delta]))) +
    scale_x_continuous(breaks = log(10^(-3:2)),
                       labels = 10^(-3:2)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_delta)) +
    NULL
```



### Within-line distribution

For estimates relating to the *within*-line distribution of $\text{logit}(\alpha)$,
I first calculated $\text{logit}(\alpha)$ for each line-rep combo,
then calculated the standard deviation of these estimates for each line.
After that, I used the mean of log-transformed SD estimates across lines, `r zeta`,
as my prior for $\zeta$.
I used $10 \times$ the SD of log-transformed SD estimates across lines, `r zeta`, 
as my prior for $\zeta$.
This results in the following weakly informative prior:


```{r alpha_within_line_sd_plot}
compare_priors("normal", zeta, sigma_zeta, xlim = zeta + c(-1,1) * sigma_zeta * 3) +
    geom_vline(xintercept = zeta) +
    ggtitle(expression(bold(S) %~% plain("Lognormal")(zeta * "," ~ sigma[zeta]))) +
    scale_x_continuous(breaks = log(10^(-3:2)),
                       labels = 10^(-3:2)) +
    coord_cartesian(ylim = c(0, 0.4 / sigma_zeta)) +
    NULL
```




# Final priors

```{r priors_table}
data_frame(
    par = c(
        "tau",
        "sigma_tau",
        "mu_theta",
        "sigma_theta",
        "gamma",
        "sigma_gamma",
        "mu_phi",
        "sigma_phi",
        "delta",
        "sigma_delta",
        "zeta",
        "sigma_zeta"
    ),
    value = c(
        tau,
        sigma_tau,
        mu_theta,
        sigma_theta,
        gamma,
        sigma_gamma,
        mu_phi,
        sigma_phi,
        delta,
        sigma_delta,
        zeta,
        sigma_zeta
    )
) %>% 
    knitr::kable(format = "html")


```

